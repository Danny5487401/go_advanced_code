# Goland随机数

随机数分为真随机和伪随机，

- 一般来说，真随机是指通过物理现象产生的，比如掷骰子、双色球摇奖（前提是机器没问题）、同位素衰变等等，其特征是不可预测、不可重现。

- 而伪随机数一般是通过软件算法产生，看上去是随机的，但是无论是什么算法函数，都会有输入和输出，如果你能得到其输入，自然也可以预测其输出。


## math/rand伪随机
官方注释
```go
// Package rand implements pseudo-random number generators.
//
// Random numbers are generated by a Source. Top-level functions, such as
// Float64 and Int, use a default shared Source that produces a deterministic
// sequence of values each time a program is run. Use the Seed function to
// initialize the default Source if different behavior is required for each run.
// The default Source is safe for concurrent use by multiple goroutines, but
// Sources created by NewSource are not.
//
// Mathematical interval notation such as [0, n) is used throughout the
// documentation for this package.
//
// For random numbers suitable for security-sensitive work, see the crypto/rand
// package.
```
翻译： 这是一个伪随机数生成器，对于高阶函数比如Float64或者Int，每次运行的时候它使用一个默认共享源来产生一个随机数。

如果你需要每次运行产生的结果不一样，那么就需要使用Seed函数初始化默认源。默认的源是协程并发安全的，但是使用NewSource函数产生的并不是。

最后，对于安全十分敏感的工作，推荐使用crypto/rand包。（注：因为这个包可以产生真随机数）

### 源码分析
```go
// Int returns a non-negative pseudo-random int from the default Source.
func Int() int { return globalRand.Int() }

var globalRand = New(&lockedSource{src: NewSource(1).(*rngSource)})

type lockedSource struct {
    lk  sync.Mutex  //锁
    src *rngSource
}

type rngSource struct {
	tap  int           // index into vec
	feed int           // index into vec
	vec  [rngLen]int64 // current feedback register
}
const (
    rngLen   = 607
    rngTap   = 273
    rngMax   = 1 << 63
    rngMask  = rngMax - 1
    int32max = (1 << 31) - 1
)

func NewSource(seed int64) Source {
    var rng rngSource
    rng.Seed(seed)
    return &rng
}
```
它们默认使用全局的源，而这个源的默认种子是固定的1.


为了每次运行产生不同的结果，我们需要使用一个随机数当种子来初始化源，最常见的做法就是使用当前时间戳：
```go
rand.Seed(time.Now().UnixNano())
```
分析
```go
func (rng *rngSource) Seed(seed int64) {
	rng.tap = 0
	rng.feed = rngLen - rngTap

	seed = seed % int32max
	if seed < 0 {
		seed += int32max
	}
	if seed == 0 {
		seed = 89482311
	}

	x := int32(seed)
	for i := -20; i < rngLen; i++ {
		x = seedrand(x)
		if i >= 0 {
			var u int64
			u = int64(x) << 40
			x = seedrand(x)
			u ^= int64(x) << 20
			x = seedrand(x)
			u ^= int64(x)
			u ^= rngCooked[i]
			rng.vec[i] = u
		}
	}
}
```


如果你真的要追求极致性能的话，你可能需要自己New一个rand，因为默认的Source为了实现并发安全使用了一个全局的排它锁，必然会带来性能损耗，
如果确实特别在意这点性能消耗的话，可以通过定义一个你的包共享的或者结构体实例共享的 Rand 实例来优化锁的性能消耗（最小化锁的粒度，不跟其他包/代码竞争这个锁）

Note: 但是请注意这个rand并不是并发安全的，如果在并发环境下使用，需要自行加锁！


## crypto/rand真随机
官方注释
```go
// Reader is a global, shared instance of a cryptographically
// secure random number generator.
//
// On Linux and FreeBSD, Reader uses getrandom(2) if available, /dev/urandom otherwise.
// On OpenBSD, Reader uses getentropy(2).
// On other Unix-like systems, Reader reads from /dev/urandom.
// On Windows systems, Reader uses the CryptGenRandom API.
// On Wasm, Reader uses the Web Crypto API.
var Reader io.Reader

// Read is a helper function that calls Reader.Read using io.ReadFull.
// On return, n == len(b) if and only if err == nil.
func Read(b []byte) (n int, err error) {
	return io.ReadFull(Reader, b)
}
```
在Linux平台下，当使用 getrandom() syscall，在int32位的机器上面上每次最多可以获取2^25-1个字节的数据。
