<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [逃逸分析](#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90)
  - [背景](#%E8%83%8C%E6%99%AF)
  - [逃逸情况](#%E9%80%83%E9%80%B8%E6%83%85%E5%86%B5)
  - [逃逸分析方式](#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E6%96%B9%E5%BC%8F)
  - [指针相关](#%E6%8C%87%E9%92%88%E7%9B%B8%E5%85%B3)
  - [参考](#%E5%8F%82%E8%80%83)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 逃逸分析
> Go values whose memory cannot be allocated this way, because the Go compiler cannot determine its lifetime, are said to escape to the heap. 

编译器使用逃逸分析技术去选择堆或者栈。基本思想是在编译时期进行垃圾收集工作。编译器追踪代码域变量的作用范围。
它使用追踪数据来检查哪些变量的生命周期是完全可知的。如果变量通过这些检查，则可以在栈上进行分配。如果没通过，也就是所说的逃逸，则必须在堆上分配。

## 背景
经常造成业务代码停顿大多数是由堆的GC造成的，所以我们能尽可能的把一些对象在栈内分配尽量些(但也不用走极端)。栈分配是很廉价的而堆分配代价是昂贵的。

Go在两个地方分配内存：用于动态分配的全局堆，以及用于每个goroutine的局部栈。Go偏向于在栈中分配----大多数go程序的分配都是在栈上面的。栈分配很廉价，因为它只需要两个CPU指令：一个是分配入栈，另一个是栈内释放。

但是不幸的是，不是所有数据都能使用栈上分配的内存。栈分配要求可以在编译时确定变量的生存期和内存占用量。然而堆上的动态分配发生在运行时。
malloc必须去找一块儿足够大的空闲内存来保存新值。然后垃圾收集器扫描堆以查找不再引用的对象。毫无疑问，它比堆栈分配使用的两条指令要贵得多。


## 逃逸情况
1. 发送指针或者是带有指针的值到channel里。编译时期没有办法知道哪个goroutine会受到channel中的数据。因此编译器无法确定这个数据什么时候不再被引用到。

2. 在slice中存储指针或者是带有指针的值。这种情况的一个例子是[]*string。它总会导致slice中的内容逃逸。尽管切片底层的数组还是在堆上，但是引用的数据逃逸到堆上了。

3. slice底层数组由于append操作超过了它的容量，它会重新分片内存。如果在编译时期知道切片的初始大小，则它会在栈上分配。如果切片的底层存储必须被扩展，数据在运行时才获取到。则它将在堆上分配。

4. 在接口类型上调用方法。对接口类型的方法调用是动态调用--接口的具体实现只有在运行时期才能确定。考虑一个接口类型为io.Reader的变量r。
   对r.Read(b)的调用将导致r的值和byte slice b的底层数组都逃逸，因此在堆上进行分配
   
5. 在方法内把局部变量指针返回时被外部引用，因此其生命周期大于栈，则溢出；

## 逃逸分析方式

逃逸分析可以在代码编译的时候可以大多数确定的，也意味着可以打开编译参数，实时查看我们的代码到底给堆造成了多大的压力；


分析工具:

- 通过编译工具查看详细的逃逸分析过程(go build -gcflags '-m -l' main.go)；
- 通过反编译命令查看go tool compile -S main.go

其中 编译参数(-gcflags)介绍:

* -N: 禁止编译优化
* -l: 禁止内联(可以有效减少程序大小)
* -m: 逃逸分析(最多可重复四次),go build '-m -m ' main.go
* -benchmem: 压测时打印内存分配统计


## 指针相关

经验法则是：指针指向堆上分配的数据。 因此，减少程序中指针的数量会减少堆分配的数量。 这不是公理，但我们发现它是现实世界Go程序中的常见情况。

我们直觉上得出的一个常见的假设是这样的：“复制值代价是昂贵的，所以我会使用指针。”然而在许多情况下，复制值比使用指针的开销要便宜的多。

原因如下：

* 在解引用一个指针的时候，编译器会生成检查。它的目的是，如果指针是nil的话，通过运行panic()来避免内存损坏。这部分额外代码必须在运行时去运行。如果数据按值传递，它不会是nil。
* 指针通常具有较差的引用局部性。函数中使用的所有值都在并置在堆栈内存中。引用局部性是代码高效的一个重要方面。它极大增加了变量在CPU caches中变热的可能性，并降低了预取时候未命中风险。
* 复制缓存行中的对象大致相当于复制单个指针。 CPU在缓存层和主存在常量大小的缓存行上之间移动内存。 在x86上，cache行是64个字节。 此外，Go使用一种名为Duff`s devices的技术，使拷贝等常见内存操作非常高效。


指针应主要用于反映成员所有关系以及可变性。实际中，使用指针避免复制应该是不常见的。不要陷入过早优化陷阱。按值传递数据习惯是好的，只有在必要的时候才去使用指针传递数据。另外，值传递消除了nil从而增加了安全性。

减少程序中指针的数量可以产生另一个有用的结果，因为垃圾收集器将跳过不包含指针的内存区域。例如，根本不扫描返回类型为[]byte 的切片的堆区域。对于不包含任何具有指针类型字段的结构类型数组，也同样适用。

减少指针不仅减少垃圾回收的工作量，还会生存出”cache友好“的代码。读取内存会将数据从主存移到CPU cache中。Caches是优先的，因此必须清掉一些数据来腾出空间。cache清掉的数据可能会和程序的其它部分相关。由此产生的cache抖动可能会导致不可预期行为和突然改变生产服务的行为

## 参考
1. [go服务之高效内存分配](https://juejin.cn/post/6844903921568186376)
